# EssayMaker 流式输出重复问题分析与解决方案

## 问题描述

在 EssayMaker 应用中，用户报告在使用第一步流式输出(firstStep)时遇到内容重复显示的问题。具体表现为：相同的内容在流式输出过程中会被完整地重复显示一次，然而第二步流式输出(secondStep)没有此问题。当用户点击查询过程中的步骤时，显示的内容会自动去重，不存在重复问题。

## 问题分析

### 初步尝试

最初的解决思路集中在前端的内容处理逻辑上：

1. 修改 React 状态更新方式
2. 调整内容累积逻辑
3. 参考`useSecondStep.ts`的简化实现

然而，这些修改均未能解决问题，表明问题的根源可能不在前端普通处理逻辑中。

### 关键发现：端点实现差异

通过分析`ps_router`和`query_router`两个端点的实现方式，发现了问题的可能根源：

| 特性     | FirstStep (Query_Router)    | SecondStep (PS_Router) |
| -------- | --------------------------- | ---------------------- |
| 实现方式 | 混合使用 JSON 响应和 SSE 流 | 纯 SSE 流式响应        |
| 处理逻辑 | 根据 agent 类型选择响应方式 | 统一使用 SSE 响应      |
| 数据格式 | 可能有重复数据发送          | 无重复数据             |

`query_router`端点在某些情况下可能会：

1. 先发送一个完整的 JSON 响应
2. 再通过 SSE 流式发送相同数据
3. 导致前端接收到完全相同的内容两次

### 重复内容的特征

观察到的重复内容具有以下特征：

1. 完整内容被整体重复一次
2. 不是小片段的重复或内容累积过程中的重叠
3. 看起来像是两次独立的完整响应被连接在一起

## 解决方案

既然问题源于后端端点特性，而非前端普通处理逻辑，我们在前端添加智能的重复检测机制来应对可能的重复数据：

### 实现代码

在`useFirstStep.ts`的`content`事件处理中添加双层重复检测：

```typescript
case "content":
  // 获取新内容
  const newContent = data.content || "";

  // 第一层：大段重复内容检测
  // 如果新内容已完全包含在累积内容中，则忽略
  if (newContent.length > 200 && accumulatedContent.includes(newContent)) {
    console.log("检测到大段重复内容，忽略");
    break; // 完全忽略这次更新
  }

  // 第二层：完整内容重复检测
  // 如果新内容包含了所有已累积内容，可能是收到了完整版本
  if (
    newContent.length > 500 &&
    newContent.includes(accumulatedContent) &&
    accumulatedContent.length > 200
  ) {
    console.log("检测到内容重复包含，使用更长的版本");
    // 使用更新的完整版本替换而不是追加
    accumulatedContent = newContent;
  } else {
    // 正常累积内容
    accumulatedContent += newContent;
  }

  // 更新UI显示
  setResult((prev) => {
    // 保持原有的条件判断
    if (prev?._isStepContent) {
      return prev;
    }

    return {
      ...prev!,
      content: accumulatedContent,
      _isStepContent: false
    };
  });
  break;
```

### 解决方案说明

1. **大段重复内容检测**

   - 针对已经在累积内容中出现过的大段内容(>200 字符)
   - 直接忽略这类重复内容，不进行处理
   - 有效避免同一内容被重复添加

2. **完整内容重复检测**

   - 检测新内容是否完全包含已有累积内容
   - 如果新内容更完整，则替换已有内容而非追加
   - 处理整体内容被重新发送的情况

3. **长度阈值设置**
   - 设置>200 字符和>500 字符的阈值避免误判
   - 只针对较长内容进行检测，不影响小片段正常累积

## 效果验证

实施上述解决方案后：

1. 不再出现内容重复显示问题
2. 保持了流式输出的实时体验
3. 不需要修改后端 API 实现

## 经验总结

1. **根因分析的重要性**：通过比较不同组件的行为和深入了解后端实现，找到问题真正根源
2. **防御性编程**：前端代码应对后端可能的不一致行为进行防御性处理
3. **问题隔离**：将问题缩小到特定场景和组件，有助于快速定位和解决
4. **适应性解决方案**：有时候适应现有系统特性的解决方案比尝试改变系统更有效

## 后续优化建议

1. **统一端点实现**：长期来看，可以考虑统一`query_router`和`ps_router`的实现方式
2. **增强日志**：添加更详细的日志记录，以便更容易发现和诊断类似问题
3. **自动化测试**：添加针对流式输出去重的自动化测试，确保功能稳定性
